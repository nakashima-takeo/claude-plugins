# test-writer - テストコード作成プラグイン

テスト計画書の作成からテストコードの実装まで、品質の高いテスト作成をサポートするClaude Codeプラグイン

## 概要

テスト設計原則に従い、モックを最小限に抑え、実際の依存関係を使用してテストを作成します。統合テストと単体テストを適切に分離し、仕様を表現するテストコードを実現します。

## コマンド一覧

### `/write-test`
テスト計画書の作成からテスト実装まで一貫して実行するコマンド

**処理フロー:**
1. テスト計画書を作成（Markdownファイル、テストフォルダ直下）
2. test-plan-reviewerエージェントが計画書をレビュー
3. 改善点がなくなるまで計画書を修正・レビューを繰り返す
4. 計画書に従ってテストを作成
5. テストがエラーなく通るまで修正
6. test-reviewerエージェントがテストをレビュー
7. 改善点がなくなるまでテストを修正・レビューを繰り返す

## テスト設計原則

### 統合テストと単体テストの区別

**統合テスト（シナリオテスト）:**
- モジュールや関数ではなく、**プロジェクトの仕様**に対して書く
- テストから仕様が理解できるようにする
- IOに対するテストは統合テストに組み込む

**単体テスト:**
- **純粋なドメインロジック**のみをテスト
- IOに対する単体テストは書かない
- 内部実装の詳細に対するテストは行わない

### テスト構造（AAA パターン）

1. **Arrange（準備）**: テストデータと前提条件を設定
2. **Act（実行）**: テスト対象の処理を実行
3. **Assert（検証）**: 期待される結果を検証

**Assertの原則:**
- 内部実装は確認しない
- 実装の詳細を変更しても壊れないAssertにする
- 出入り口の値や処理のみ確認する

### 命名規則

- **日本語**を用いる
- テストメソッド名: `系：確認対象の仕様`
  - 系: `正常系` または `異常系`
  - 例: `正常系：ユーザー登録が成功する`

### 品質基準

- テストの意図が明確で、他の開発者が読んで理解できる
- テストデータは意味のある値を使用（magic numberを避ける）
- テストコードが仕様書としての役割を果たす

## モックの使用方針

### 基本原則
- モックは**外部システムとの境界でのみ**使用
- 内部の依存関係やドメインオブジェクトはモックしない
- 複数箇所で使用するモックは一箇所にまとめる

### モック使用の判断基準

| 対象 | モック使用 |
|------|-----------|
| 外部API呼び出し | ✅ モック使用 |
| データベースアクセス | テスト用DBまたはモック |
| ファイルI/O | ✅ モック使用 |
| 内部サービスクラス | ❌ 実際のインスタンス使用 |
| ドメインオブジェクト | ❌ 実際のインスタンス使用 |

## エージェント一覧

### test-plan-reviewer
テスト計画書の品質をレビューする専門エージェント

**レビュー観点:**
- 統合テスト・単体テストの妥当性
  - 統合テストが仕様に対して書かれているか
  - 単体テストがドメインロジックのみに焦点を当てているか
  - 内部実装の詳細に対するテストになっていないか
- 命名規則（日本語、「系：仕様」形式）の遵守

**出力:**
- 修正が必須の内容のみを指摘

### test-reviewer
テストコードの品質をレビューする専門エージェント

**レビュー観点:**
1. テスト計画に従っているか
2. 統合テスト・単体テストの妥当性
3. 命名規則の遵守
4. モックの適切な使用
5. テスト構造（Arrange・Act・Assert）
6. Assert対象の妥当性
7. 可読性

**出力:**
- 修正が必須の内容のみを指摘

## 使用例

```bash
# テスト計画書の作成からテスト実装まで一貫実行
/write-test
```

## 特徴

- **仕様駆動**: 統合テストが仕様書として機能
- **最小限のモック**: 外部システムとの境界のみモック化
- **レビュー自動化**: 計画書とテストコードの両方を自動レビュー
- **高い可読性**: 日本語命名と明確な構造でテストの意図を表現
- **YAGNI原則**: 必要最小限のテストコードで最大の価値を提供
